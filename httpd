#!/usr/bin/env python
# -*- coding: UTF-8 -*-

import os
from flask import Flask, url_for
from flask import Response
from flask import render_template
from flask import abort
from flask import request
from flask import jsonify
from flask import redirect

import sqlite3
from datetime import datetime
from urllib import quote_plus
from PIL import Image
import StringIO
from config import *

app = Flask(__name__)

def dbconn():
	con = sqlite3.connect(db)
	cur = con.cursor()
	return (con, cur)	
	
def get_data(cur, step=20, start=0):
	sql = "SELECT * FROM playlist ORDER BY dt DESC LIMIT %d OFFSET %d" % (step, start)
	cur.execute(sql)

def create_thumbnail(rawdata):
	#response = Response(rec[2], mimetype=rec[1])
	img = StringIO.StringIO(rawdata)
	image = Image.open(img)

	orig_size = image.size
	#print orig_size
	new_height = thumbnail_height
	new_width = int(round((0.0+orig_size[0])*(new_height/(0.0+orig_size[1]))))
	#print (new_width, new_height)

	thumbnail = image.resize((new_width, new_height), Image.ANTIALIAS)

	out = StringIO.StringIO()
	thumbnail.save(out, format=image.format)

	return out.getvalue()

@app.route('/csv')
def csv():
	con, cur = dbconn()
	
	con, cur = dbconn()
	get_data(cur, step=limit)	
	
	buffer = "id;unix-tst;title;artist;album\n"
	
	while True:
		row = cur.fetchone()
		if row == None:
			break
		buffer += str(row[0]) + ";\"" + unicode(row[1]) + "\";\"" + \
		          unicode(row[2]) + "\";\"" + unicode(row[3]) + "\";\"" + "\n"
	
	return Response(buffer, mimetype='text/plain')


@app.route('/thumbnail/<int:id>', methods=['GET', 'HEAD'])
def thumbnail(id):

	con, cur = dbconn()
	sql = "SELECT thumb_size, contenttype, thumb_data FROM covers WHERE id = ?"
	cur.execute(sql, (id,))
	rec = cur.fetchone()
	if rec == None:
		return redirect("/thumbnail/397")
	
	size = rec[0]
	contenttype = rec[1]
	data = rec[2]
	
	# if the thubnail has not yet been generated, create it
	if not size:
		#print "resizing"
		sql = "SELECT size, contenttype, data FROM covers WHERE id = ?"
		cur.execute(sql, (id,))
		rec = cur.fetchone()
		
		try:
			data = create_thumbnail(rec[2])
			size = int(len(data))
		except:
			return redirect("/thumbnail/397")
		
		# update covers
		sql = "UPDATE covers SET thumb_data=?, thumb_size=? WHERE id=?"
		cur.execute(sql, (sqlite3.Binary(data), size, id))
		con.commit()
		
	response = Response(data, mimetype=contenttype)
	response.headers.add('Date', 'Sat, 03 Dec 2016 08:51:59 GMT')
	response.headers.add('Cache-Control', 'public')
	response.cache_control.max_age = 31536000
	response.headers.add('Content-Length', size)
	return response


@app.route('/cover/<int:id>', methods=['GET', 'HEAD'])
def cover(id):
	con, cur = dbconn()
	sql = "SELECT size, contenttype, data FROM covers WHERE id = ?"
	cur.execute(sql, (id,))
	rec = cur.fetchone()
	if rec == None or len(rec[2]) == 0:
		abort(404)
	
	response = Response(rec[2], mimetype=rec[1])
	
	"""
	request.headers.get('your-header-name')
	response.headers.add('Last-Modified', 'Wed, 21 Oct 2015 07:28:00 GMT')
	response.headers.add('Cache-Control', 'public, max-age=31536000')
	response.headers.add('If-Modified-Since', 'Sat, 03 Dec 2016 08:51:59 GMT')
	"""
	
	response.headers.add('Date', 'Sat, 03 Dec 2016 08:51:59 GMT')
	response.headers.add('Cache-Control', 'public')
	response.cache_control.max_age = 31536000
	response.headers.add('Content-Length', rec[0])
	return response

@app.route('/like')
def like():
	con, cur = dbconn()
	sql = "INSERT INTO like (dt) VALUES (?)"
	tst = int(datetime.now().strftime("%s"))
	cur.execute(sql, (tst,))
	con.commit();
	return "saved: %d" % tst
		
@app.route('/mobile')
def mobile():
	
	fp = open(last_update, "r")
	lastupdate = fp.read()
	fp.close()
	
	con, cur = dbconn()
	get_data(cur, step=50)	
	
	res = cur.fetchall()
	records = []
	for row in res:
		r = []
		r.append(str(row[0]))
		r.append(quote_plus(row[2].encode('utf8') + " " + row[3].encode('utf8')))
		r.append(str(datetime.fromtimestamp(row[1]).strftime('%d.%m.%y %H:%M')))
		r.append(unicode(row[2]))
		r.append(unicode(row[3]))
		r.append(unicode(row[4]))
		r.append(row[5])
		records.append(r)
	
	con.close()
	return render_template('mobile.html', records=records, lastupdate=lastupdate)

@app.route('/')
def playlist():
	
	fp = open(last_update, "r")
	lastupdate = fp.read()
	fp.close()
	
	con, cur = dbconn()
	get_data(cur, step=50)	
	
	res = cur.fetchall()
	records = []
	for row in res:
		r = []
		r.append(str(row[0]))
		r.append(quote_plus(row[2].encode('utf8') + " " + row[3].encode('utf8')))
		r.append(str(datetime.fromtimestamp(row[1]).strftime('%d.%m.%y %H:%M')))
		r.append(unicode(row[2]))
		r.append(unicode(row[3]))
		r.append(unicode(row[4]))
		r.append(row[5])
		records.append(r)
	
	con.close()
	return render_template('playlist.html', records=records, lastupdate=lastupdate)
		
@app.route('/likes')
def like_list():
	
	fp = open(last_update, "r")
	lastupdate = fp.read()
	fp.close()
	
	con, cur = dbconn()
	sql = "SELECT * FROM like ORDER BY dt DESC LIMIT %d" % limit
	cur.execute(sql)
	res = cur.fetchall()
	
	ret = []
	for e in res:
		sql = """SELECT * 
		         FROM playlist 
		         WHERE dt < %d and dt > %d 
		         ORDER BY dt DESC 
		         LIMIT 1""" % (e[1], e[1]-60*60*8)
		cur.execute(sql)
		row = cur.fetchone()

		r = []
		r.append(str(row[0]))
		r.append(quote_plus(row[2].encode('utf8') + " " + row[3].encode('utf8')))
		r.append(str(datetime.fromtimestamp(row[1]).strftime('%d.%m.%y %H:%M')))
		r.append(unicode(row[2]))
		r.append(unicode(row[3]))
		r.append(unicode(row[4]))
		r.append(row[5])
		ret.append(r)

		
	con.close()
	return render_template('playlist.html', records=ret, lastupdate=lastupdate)
	return jsonify({"res": ret})
		
if __name__ == "__main__":
	
	# observe template and static file changes 
	extra_dirs = ['static', 'templates',]
	extra_files = extra_dirs[:]
	for extra_dir in extra_dirs:
		for dirname, dirs, files in os.walk(extra_dir):
			for filename in files:
				filename = os.path.join(dirname, filename)
				if os.path.isfile(filename):
					extra_files.append(filename)


	app.run(debug=True, extra_files=extra_files)
	#app.run(host='0.0.0.0', threaded=True)  
